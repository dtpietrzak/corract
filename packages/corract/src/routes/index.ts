import type { Express, Request, RequestHandler, Response } from "express";
import type { ViteDevServer } from "vite";
import type { RouteConfig } from "./_types";

import fs from "node:fs/promises";
import path from "node:path";
import isObject from "isobject";

export const checkRoutes = (routes: RouteConfig): boolean => {
  if (!isObject(routes)) {
    throw new Error("Routes must be a RouteConfig object!");
  }

  for (const routePath of Object.keys(routes)) {
    if (typeof routePath !== "string" || !routePath.startsWith("/")) {
      throw new Error(
        `Invalid route: ${routePath}. Routes must be strings starting with '/'`,
      );
    }
  }

  return true;
};

export const registerRoutes = (props: {
  app: Express;
  vite: ViteDevServer;
  routes: RouteConfig;
}): void => {
  for (const routePath of Object.keys(props.routes)) {
    const routeConfig = props.routes[routePath];

    // Destructure middleware or use empty array if none
    const middlewares = routeConfig.middleware || [];
    const middlewareFunctions: RequestHandler[] = middlewares.map(
      (middleware) => {
        return async (req: Request, res: Response, next: Function) => {
          try {
            // Call the middleware function and get derived data
            const serverDerivedData = await middleware({
              req: req,
              res: res,
            });
            // Attach the derived data to the request object
            if (!(req as any).serverDerivedData) {
              (req as any).serverDerivedData = {};
            }
            (req as any).serverDerivedData[middleware.name] = serverDerivedData;
            next();
          } catch (error) {
            // Handle any errors from the middleware
            props.vite.config.logger.error(
              `Error in middleware for ${req.url}: ${error}`,
            );
            res.status(500).send("Internal Server Error");
          }
        };
      },
    );

    // Compose the final handler
    const handler = async (req: Request, res: Response) => {
      props.vite.config.logger.info(`Transforming HTML for ${req.url}`);
      const html = await fs.readFile(path.resolve("index.html"), "utf-8");

      const data = (req as any).serverDerivedData;
      const script = `<script>window.__SERVER_DERIVED_DATA__ = ${
        JSON.stringify(data)
      };</script>`;
      const dataInjected = html.replace("</body>", `${script}</body>`);

      const transformed = await props.vite.transformIndexHtml(
        req.url,
        dataInjected,
      );

      res.send(transformed);
    };

    // Register route with middleware and handler
    props.app.get(routePath, ...middlewareFunctions, handler);
  }
};

export const buildAppEntry = (props: {
  routes: RouteConfig;
}) => {
  const routePaths = Object.keys(props.routes);
  // Generate imports and routes
  const imports = routePaths
    .map(
      (routePath, i) => `import Page${i} from "./pages${routePath}";`,
    )
    .join("\n");

  const routesJsx = routePaths
    .map((routePath, i) => `      <Page${i} path="${routePath}" />`)
    .join("\n");

  const content = `
/**
 * NOTE: This file is auto-generated by Corract!
 * If you modify it, your changes will be lost on the next dev / build.
 * 
 * - App Entry Point -
 * 
 * This is the entry point for a Preact application.
 * 
 * The current plan is to allow drivers to be set up to use this framework
 * with different ui libraries, routing libraries, state management, etc.
 */

import { render } from "preact";
import Router from "preact-router";
${imports}

function App() {
  return (
    <Router>
${routesJsx}
    </Router>
  );
}

render(<App />, document.getElementById("app")!);
`;

  // Write directly to the app's src/app-entry.tsx
  fs.writeFile("src/app-entry.tsx", content);
  console.log("Generated src/app-entry.tsx");
};
