import type { Express, Request, RequestHandler, Response } from "express";
import type { ViteDevServer } from "vite";
import type { RouteConfig } from "./_types";

import fs from "node:fs/promises";
import path from "node:path";
import isObject from "isobject";

export type RouteStringsParsed = {
  raw: string;
  sanitized: string;
  importString: string;
  jsxString: string;
};

export const checkRoutes = (routes: RouteConfig): boolean => {
  if (!isObject(routes)) {
    throw new Error("Routes must be a RouteConfig object!");
  }

  for (const routePath of Object.keys(routes)) {
    if (typeof routePath !== "string" || !routePath.startsWith("/")) {
      throw new Error(
        `Invalid route: ${routePath}. Routes must be strings starting with '/'`,
      );
    }
  }

  return true;
};

export const registerRoutes = (props: {
  app: Express;
  vite: ViteDevServer;
  routes: RouteConfig;
}): void => {
  for (const routePath of Object.keys(props.routes)) {
    const routeConfig = props.routes[routePath];

    // Destructure middleware or use empty array if none
    const middlewares = routeConfig.middleware || [];
    const middlewareFunctions: RequestHandler[] = middlewares.map(
      (middleware) => {
        return async (req: Request, res: Response, next: Function) => {
          try {
            // Call the middleware function and get derived data
            const serverDerivedData = await middleware({
              req: req,
              res: res,
            });
            // Attach the derived data to the request object
            if (!(req as any).serverDerivedData) {
              (req as any).serverDerivedData = {};
            }
            (req as any).serverDerivedData[middleware.name] = serverDerivedData;
            next();
          } catch (error) {
            // Handle any errors from the middleware
            props.vite.config.logger.error(
              `Error in middleware for ${req.url}: ${error}`,
            );
            res.status(500).send("Internal Server Error");
          }
        };
      },
    );

    // Compose the final handler
    const handler = async (req: Request, res: Response) => {
      props.vite.config.logger.info(`Transforming HTML for ${req.url}`);
      const html = await fs.readFile(path.resolve("index.html"), "utf-8");

      const data = (req as any).serverDerivedData;
      const script = `<script>window.__SERVER_DERIVED_DATA__ = ${
        JSON.stringify(data)
      };</script>`;
      const dataInjected = html.replace("</body>", `${script}</body>`);

      const transformed = await props.vite.transformIndexHtml(
        req.url,
        dataInjected,
      );

      res.send(transformed);
    };

    // Register route with middleware and handler
    props.app.get(routePath, ...middlewareFunctions, handler);
  }
};

export const parseRoutes = (routes: RouteConfig): RouteStringsParsed[] => {
  const routePaths = Object.keys(routes);
  return routePaths.map((routePath, i) => {
    console.log(`Processing route: ${routePath}`);
    const pathParts = routePath.split("/");
    const sanitizedPath = pathParts.map((pathPart) => {
      if (pathPart.startsWith(":")) return `(${pathPart.slice(1)})`;
      return pathPart;
    }).join("/");
    return {
      raw: routePath,
      sanitized: sanitizedPath,
      importString: `import Page${i} from "./pages${sanitizedPath}";`,
      jsxString: `      <Page${i} path="${routePath}" />`,
    };
  });
};

async function fileExists(path: string): Promise<boolean> {
  try {
    await fs.access(path, fs.constants.F_OK);
    return true;
  } catch {
    return false;
  }
}

export const buildPages = async (props: {
  routeStrings: RouteStringsParsed[];
}) => {
  await Promise.all(props.routeStrings.map(async (route) => {
    // check if file already exists
    const filePath = `src/pages${route.sanitized}/index.tsx`;
    console.log(`Checking if file exists: ${filePath}`);

    if (await fileExists(filePath)) return;
    console.log(`File does not exist, generating: ${filePath}`);

    // Ensure the directory exists
    const dirPath = `src/pages${route.sanitized}`;

    console.log(`Ensuring directory exists: ${dirPath}`);
    await fs.mkdir(dirPath, { recursive: true });
    console.log(`Generating page at: ${filePath}`);

    // Create the page template
    const pageTemplate = `
import { Page } from "corract";

export const MyPage: Page<"${route.raw}"> = (props) => {
  return (
    <>
      <h1>My Page</h1>
      <a href="/">Go Home</a>
    </>
  );
}

export default MyPage;
`;

    fs.writeFile(filePath, pageTemplate);
  }));
};

export const buildAppEntry = (props: {
  routeStrings: RouteStringsParsed[];
}) => {
  const imports = props.routeStrings.map((route) => route.importString).join(
    "\n",
  );
  const jsx = props.routeStrings.map((route) => route.jsxString).join("\n");

  const content = `
/**
 * NOTE: This file is auto-generated by Corract!
 * If you modify it, your changes will be lost on the next dev / build.
 * 
 * - App Entry Point -
 * 
 * This is the entry point for a Preact application.
 * 
 * The current plan is to allow drivers to be set up to use this framework
 * with different ui libraries, routing libraries, state management, etc.
 */

import { render } from "preact";
import Router from "preact-router";

${imports}

function App() {
  return (
    <Router>
${jsx}
    </Router>
  );
}

render(<App />, document.getElementById("app")!);
`;

  // Write directly to the app's src/app-entry.tsx
  fs.writeFile("src/app-entry.tsx", content);
  console.log("Generated src/app-entry.tsx");
};
